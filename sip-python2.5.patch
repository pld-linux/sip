diff -ur sip-4.4.5/siplib/objmap.c sip-4.4.5.phh/siplib/objmap.c
--- sip-4.4.5/siplib/objmap.c	2006-06-10 13:36:40.000000000 +0200
+++ sip-4.4.5/siplib/objmap.c	2006-07-14 17:21:18.053987000 +0200
@@ -114,8 +114,8 @@
 		 * of it, or vice versa, then we assume it is the same C++
 		 * object.
 		 */
-		if (PyObject_TypeCheck(w,&type -> super.type) ||
-		    PyType_IsSubtype(&type -> super.type,w -> ob_type))
+		if (PyObject_TypeCheck(w,&type -> super.ht_type) ||
+		    PyType_IsSubtype(&type -> super.ht_type,w -> ob_type))
 			return w;
 	}
 
diff -ur sip-4.4.5/siplib/sip.h sip-4.4.5.phh/siplib/sip.h
--- sip-4.4.5/siplib/sip.h	2006-06-10 13:36:41.000000000 +0200
+++ sip-4.4.5/siplib/sip.h	2006-07-15 11:12:32.928487750 +0200
@@ -873,6 +873,12 @@
 #define	sipTypeIsAbstract(wt)	((wt)->type->td_flags & SIP_TYPE_ABSTRACT)
 #define	sipTypeHasSCC(wt)	((wt)->type->td_flags & SIP_TYPE_SCC)
 
+//Hack to build against python 2.5
+#if PY_MAJOR_VERSION==2 && PY_MINOR_VERSION <= 4
+#define ht_type type
+#define ht_name name
+#endif
+
 
 #ifdef __cplusplus
 }
diff -ur sip-4.4.5/siplib/siplib.c sip-4.4.5.phh/siplib/siplib.c
--- sip-4.4.5/siplib/siplib.c	2006-06-10 13:36:40.000000000 +0200
+++ sip-4.4.5/siplib/siplib.c	2006-07-14 17:20:48.400133750 +0200
@@ -396,7 +396,7 @@
 	if (PyType_Ready(&sipWrapperType_Type) < 0)
 		Py_FatalError("sip: Failed to initialise sip.wrappertype type");
 
-	if (PyType_Ready(&sipWrapper_Type.super.type) < 0)
+	if (PyType_Ready(&sipWrapper_Type.super.ht_type) < 0)
 		Py_FatalError("sip: Failed to initialise sip.wrapper type");
 
 	if (PyType_Ready(&sipVoidPtr_Type) < 0)
@@ -830,7 +830,7 @@
 		{
 			sipWrapperType *wt;
 
-			if ((wt = *mw++) != NULL && addInstances(wt->super.type.tp_dict, &wt->type->td_instances) < 0)
+			if ((wt = *mw++) != NULL && addInstances(wt->super.ht_type.tp_dict, &wt->type->td_instances) < 0)
 				return -1;
 		}
 
@@ -3181,7 +3181,7 @@
 	if (type->td_scope.sc_flag)
 		dict = mod_dict;
 	else
-		dict = getClassType(&type->td_scope, client)->super.type.tp_dict;
+		dict = getClassType(&type->td_scope, client)->super.ht_type.tp_dict;
 
 	/* Add the type to the "parent" dictionary. */
 	if (PyDict_SetItem(dict,name,(PyObject *)wt) < 0)
@@ -3231,7 +3231,7 @@
 	if (ed->e_scope < 0)
 		dict = mod_dict;
 	else
-		dict = client->em_types[ed->e_scope]->super.type.tp_dict;
+		dict = client->em_types[ed->e_scope]->super.ht_type.tp_dict;
 
 	/* Create the base type tuple if it hasn't already been done. */
 	if (bases == NULL && (bases = Py_BuildValue("(O)",&PyInt_Type)) == NULL)
@@ -3417,7 +3417,7 @@
 
 	self = PyTuple_GET_ITEM(args,argnr);
 
-	if (!PyObject_TypeCheck(self,&type -> super.type))
+	if (!PyObject_TypeCheck(self,&type -> super.ht_type))
 		return PARSE_UNBOUND;
 
 	*selfp = (sipWrapper *)self;
@@ -4288,7 +4288,7 @@
 {
 	/* If this is a wrapped type then get the type dictionary. */
 	if (sipWrapperType_Check(dict))
-		dict = ((sipWrapperType *)dict)->super.type.tp_dict;
+		dict = ((sipWrapperType *)dict)->super.ht_type.tp_dict;
 
 	return addSingleEnumInstance(dict, name, value, type);
 }
@@ -4338,7 +4338,7 @@
 {
 	/* If this is a wrapped type then get the type dictionary. */
 	if (sipWrapperType_Check(dict))
-		dict = ((sipWrapperType *)dict) -> super.type.tp_dict;
+		dict = ((sipWrapperType *)dict) -> super.ht_type.tp_dict;
 
 	return addSingleClassInstance(dict,name,cppPtr,wt,0);
 }
@@ -4355,7 +4355,7 @@
 
 	/* If this is a wrapped type then get the type dictionary. */
 	if (sipWrapperType_Check(dict))
-		dict = ((sipWrapperType *)dict)->super.type.tp_dict;
+		dict = ((sipWrapperType *)dict)->super.ht_type.tp_dict;
 
 	if ((w = mt->mt_cfrom(cppPtr, NULL)) == NULL)
 		return -1;
@@ -4534,7 +4534,7 @@
 	if (pyObj == Py_None)
 		ok = ((flags & SIP_NOT_NONE) == 0);
 	else if (cto == NULL || (flags & SIP_NO_CONVERTORS) != 0)
-		ok = PyObject_TypeCheck(pyObj, &type->super.type);
+		ok = PyObject_TypeCheck(pyObj, &type->super.ht_type);
 	else
 		ok = cto(pyObj, NULL, NULL, NULL);
 
@@ -4954,7 +4954,7 @@
 			 * convertor might be able to convert the target type
 			 * to something more specific.
 			 */
-			if (PyType_IsSubtype(&type -> super.type,&scc -> scc_basetype -> super.type))
+			if (PyType_IsSubtype(&type -> super.ht_type,&scc -> scc_basetype -> super.ht_type))
 			{
 				sipWrapperType *subtype;
 
@@ -5508,7 +5508,7 @@
 	 * We check by comparing the actual type name with the name used to
 	 * create the original wrapped type.
 	 */
-	if ((name = PyString_AsString(wt->super.name)) == NULL)
+	if ((name = PyString_AsString(wt->super.ht_name)) == NULL)
 		return FALSE;
 
 	return (strcmp(name, getBaseName(wt->type->td_name)) == 0);
@@ -5564,7 +5564,7 @@
 	 */
 	if (self -> type == NULL)
 	{
-		PyObject *sc = (PyObject *)self->super.type.tp_base;
+		PyObject *sc = (PyObject *)self->super.ht_type.tp_base;
 
 		/*
 		 * Make sure that the type is derived from sip.wrapper.  It
@@ -5573,7 +5573,7 @@
 		 */
 		if (sc == NULL || !sipWrapperType_Check(sc))
 		{
-			PyErr_Format(PyExc_TypeError, "type %s must be derived from sip.wrapper", self->super.type.tp_name);
+			PyErr_Format(PyExc_TypeError, "type %s must be derived from sip.wrapper", self->super.ht_type.tp_name);
 			return -1;
 		}
 
@@ -5608,7 +5608,7 @@
 		PyObject *dict;
 		PyMethodDef *pmd;
 
-		dict = wt -> super.type.tp_dict;
+		dict = wt -> super.ht_type.tp_dict;
 
 		/* The base type doesn't have any type information. */
 		if ((td = wt->type) == NULL || !isExactWrappedType(wt))
@@ -5826,7 +5826,7 @@
 		}
 
 		/* See if it is an abstract type. */
-		if (sipTypeIsAbstract(wt) && strcmp(strchr(wt->type->td_name, '.') + 1, wt->super.type.tp_name) == 0)
+		if (sipTypeIsAbstract(wt) && strcmp(strchr(wt->type->td_name, '.') + 1, wt->super.ht_type.tp_name) == 0)
 		{
 			PyErr_Format(PyExc_TypeError, "%s represents a C++ abstract class and cannot be instantiated", wt->type->td_name);
 
@@ -5835,7 +5835,7 @@
 	}
 
 	/* Call the standard super-type new. */
-	return PyBaseObject_Type.tp_new(&wt -> super.type,args,kwds);
+	return PyBaseObject_Type.tp_new(&wt -> super.ht_type,args,kwds);
 }
 
 
@@ -6402,7 +6402,7 @@
 
 	/* Add the slots for this type. */
 	if (td -> td_pyslots != NULL)
-		initSlots(&wt->super.type, &wt->super.as_number, &wt->super.as_sequence, &wt->super.as_mapping, td->td_pyslots, FALSE);
+		initSlots(&wt->super.ht_type, &wt->super.as_number, &wt->super.as_sequence, &wt->super.as_mapping, td->td_pyslots, FALSE);
 
 	/* Recurse through any super-types. */
 	if ((sup = td -> td_supers) != NULL)
